// grafar.ms() подходит для самого частого кейса -- явной зависимости от времени.
// Неявную анимацию так сделать не выйдет, потому что vsolve не может зависеть от
// других графар-переменных.

// Анимируем линию уровня такой функции:
const fun = (x, y) => x * Math.log(Math.pow(y, 2) + 1) + x / 2;
// Это фабрика генераторов линий уровня: fun === a.
const levelGen = a => grafar.vsolve((v => fun(v[0], v[1]) - a), 1000, 2);

// для начала просто решаем и отображаем
const levelset = levelGen(0).select();
const pan = new grafar.Panel(document.getElementById('render')).setAxes(['x', 'y']);
grafar.pin(levelset, pan);


// ** Вот и сама анимация. grafar.ms() внутри делает то же самое. **
// Сперва создадим переменную, которая будет меняться:
let t = 0;
// Теперь функция, которая все обновляет:
const up = () => {
    // сперва увеличиваем время
    t += .005;
    // Берем синус, чтобы наша линия уровня ходила по кругу, а не убегала слишком далеко.
    const p = Math.sin(t);
    // Как при управлении из интерфейса, используем <Generator>.into(<selection>)
    levelGen(p).into(levelset);
    // И просим вызвать еще раз
    window.requestAnimationFrame(up);
};
// Запускаем!
up();
