// ** Обертки **

// Обернуть одно число
const gens = [
  grafar.constant(0).select(),

  // Обернуть множество чисел
  grafar.set([-1, 0, 1]).select(),
  // Несмотря на название, элементы никак не проверяются на уникальность:
  // grafar.set([0, 0, 0]).select()
  // Массив копируется, и от изменения вашей копии в графаре ничего не поменяется:
  // const outer = [1, 2];
  // const grafarCopy = grafar.set(outerSet).select();

  // ** Явные генераторы **

  // Классика: seq(a, b, n) генерирует n точек, расположенных равномерно на
  // отрезке [a, b], включая границы. Точки никак не соединяются, то есть изображаем
  // { a + i * (b - a) / (n - 1) | i = 0..n }.
  grafar.seq(-1, 1, 20).select(),

  // Те же точки, но соединенные (получается отрезок)
  grafar.range(-1, 1, 20).select(),

  // Логарифмическая последовательность: ближе к a больше точек.
  // Если интересуетесь, { a + log(i) * (b - a) / log(n)) * (b - a) | i = 0..n }
  // Полезно, чтобы потом применить к этому отображение, сильнее искревлённое около a
  grafar.logseq(-1, 1, 20).select(),

  // Целые числа между a и b, включая границы.
  grafar.ints(-2, 2).select(),
  // Правильно обрабатывает сомнительные случаи:
  // const ints5 = grafar.ints(-.3, 5.9);
];

grafar.setup({ particleRadius: .2 });
const pan = new grafar.Panel(document.getElementById('render')).setAxes(['x', 'y']);
gens.forEach((gen, i) => {
  grafar.pin([ gen, grafar.constant((i - 3) / 2).select() ], pan);
});

// ** Неявный генератор **

// Найти нули функции.
const circle = grafar.vsolve(
  // Функция. Аккуратно, аргументы передаются в массиве, а не как обычно.
  v => Math.pow(v[0], 2) + Math.pow(v[1], 2) - 2,
  // Сколько решений найти
  1000,
  // Размерность объекта. Сейчас строим неявную поверхность на плоскости, так что 2.
  2
).select();
// Техническая минутка. Решение выглядит как куча точек, случайно расположенных
// в разных нулях функции. Закрашенную поверхность или линию таким образом построить
// не получится. Если получается жиденько, увеличьте второй параметр -- можно
// смело гонять по 100000 точек для трехмерного уравнения.
// Жизнь полна компромиссов. Вот еще немного:
//  1. Не нужно явно указывать область, в которой ищем решения. Хотя лучше всего
//     ищутся решения неподалеку от начала координат.
//  2. Работает для вырожденных объектов:
//    - Находит кратные нули, когда целевая функция не пересекает ноль, а только
//      касается его (производная тоже 0). Например, sin(x) == -1
//    - Находит решения неожиданной топологической размерности: например, неявные
//      кривые и точки в R^3 (x^2 + y^2 + z^2 == 0).
//  3. Решает уравнения в пространстве любой размерности (но комбинаторный взрыв догоняет)

const iPan = new grafar.Panel(document.getElementById('implicit')).setAxes(['x', 'y']);
grafar.pin(circle, iPan);
