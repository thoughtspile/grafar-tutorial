"use strict";

// ** Обертки **

// Обернуть одно число
var constant = grafar.constant(0).select();

// Обернуть множество чисел
var set = grafar.set([0, 1, 2]).select();
// Несмотря на название, элементы никак не проверяются на уникальность:
var nonset = grafar.set([0, 0, 0]).select();
// Массив копируется, и от изменения вашей копии в графаре ничего не поменяется:
var outer = [1, 2];
var grafarCopy = grafar.set(outerSet).select();

// ** Явные генераторы **

// Классика: seq(a, b, n) генерирует n точек, расположенных равномерно на
// отрезке [a, b], включая границы. Точки никак не соединяются, то есть изображаем
// { a + i * (b - a) / (n - 1) | i = 0..n }.
var seq = grafar.seq(0, 1, 20).select();

// Те же точки, но соединенные (получается отрезок)
var range = grafar.range(0, 1, 20).select();

// Логарифмическая последовательность: ближе к a больше точек.
// Если интересуетесь, { a + log(i) * (b - a) / log(n)) * (b - a) | i = 0..n }
// Полезно, чтобы потом применить к этому отображение, сильнее искревлённое около a
var logseq = grafar.logseq(0, 1, 20).select();

// Целые числа между a и b, включая границы.
var ints = grafar.ints(0, 5);
// Правильно обрабатывает сомнительные случаи:
var ints5 = grafar.ints(-.3, 5.9);

// ** Неявный генератор **

// Найти нули функции.
var circle = grafar.vsolve(
// Функция. Аккуратно, аргументы передаются в массиве, а не как обычно.
function (v) {
  return Math.pow(v[0], 2) + Math.pow(v[1], 2) - 2;
},
// Сколько решений найти
1000,
// Размерность объекта. Сейчас строим неявную поверхность на плоскости, так что 2.
2);
// Техническая минутка. Решение выглядит как куча точек, случайно расположенных
// в разных нулях функции. Закрашенную поверхность или линию таким образом построить
// не получится. Если получается жиденько, увеличьте второй параметр -- можно
// смело гонять по 100000 точек для трехмерного уравнения.
// Жизнь полна компромиссов. Вот еще немного:
//  1. Не нужно явно указывать область, в которой ищем решения. Хотя лучше всего
//     ищутся решения неподалеку от начала координат.
//  2. Работает для вырожденных объектов:
//    - Находит кратные нули, когда целевая функция не пересекает ноль, а только
//      касается его (производная тоже 0). Например, sin(x) == -1
//    - Находит решения неожиданной топологической размерности: например, неявные
//      кривые и точки в R^3 (x^2 + y^2 + z^2 == 0).
//  3. Решает уравнения в пространстве любой размерности (но комбинаторный взрыв догоняет)