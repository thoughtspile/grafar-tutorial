// ** Обертки **

// Обернуть одно число
const constant = grafar.constant(0).select();

// Обернуть множество чисел
const set = grafar.set([0, 1, 2]).select();
// Несмотря на название, элементы никак не проверяются на уникальность:
const nonset = grafar.set([0, 0, 0]).select();
// Массив копируется, и от изменения вашей копии в графаре ничего не поменяется:
const outer = [1, 2];
const grafarCopy = grafar.set(outerSet).select();


// ** Явные генераторы **

// Классика: seq(a, b, n) генерирует n точек, расположенных равномерно на
// отрезке [a, b], включая границы. Точки никак не соединяются, то есть изображаем
// { a + i * (b - a) / (n - 1) | i = 0..n }.
const seq = grafar.seq(0, 1, 20).select();

// Те же точки, но соединенные (получается отрезок)
const range = grafar.range(0, 1, 20).select();

// Логарифмическая последовательность: ближе к a больше точек.
// Если интересуетесь, { a + log(i) * (b - a) / log(n)) * (b - a) | i = 0..n }
// Полезно, чтобы потом применить к этому отображение, сильнее искревлённое около a
const logseq = grafar.logseq(0, 1, 20).select();

// Целые числа между a и b, включая границы.
const ints = grafar.ints(0, 5);
// Правильно обрабатывает сомнительные случаи:
const ints5 = grafar.ints(-.3, 5.9);


// ** Неявный генератор **

// Найти нули функции.
const circle = grafar.vsolve(
  // Функция. Аккуратно, аргументы передаются в массиве, а не как обычно.
  v => Math.pow(v[0], 2) + Math.pow(v[1], 2) - 2,
  // Сколько решений найти
  1000,
  // Размерность объекта. Сейчас строим неявную поверхность на плоскости, так что 2.
  2
);
// Техническая минутка. Решение выглядит как куча точек, случайно расположенных
// в разных нулях функции. Закрашенную поверхность или линию таким образом построить
// не получится. Если получается жиденько, увеличьте второй параметр -- можно
// смело гонять по 100000 точек для трехмерного уравнения.
// Жизнь полна компромиссов. Вот еще немного:
//  1. Не нужно явно указывать область, в которой ищем решения. Хотя лучше всего
//     ищутся решения неподалеку от начала координат.
//  2. Работает для вырожденных объектов:
//    - Находит кратные нули, когда целевая функция не пересекает ноль, а только
//      касается его (производная тоже 0). Например, sin(x) == -1
//    - Находит решения неожиданной топологической размерности: например, неявные
//      кривые и точки в R^3 (x^2 + y^2 + z^2 == 0).
//  3. Решает уравнения в пространстве любой размерности (но комбинаторный взрыв догоняет)
